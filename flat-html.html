<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>flat-html live</title>
  <meta name="description" content="">
  <meta name="author" content="">

 <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/react/16.10.2/umd/react.development.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.10.2/umd/react-dom.development.js" type="text/javascript"></script>
<link href="http://maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet" id="bootstrap-css">
<script src="http://maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js"></script>

<!------ Include the above in your HEAD tag ---------->


<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css" type="text/css" rel="stylesheet">

	<style>
	#input {
		float: left;
		top: 0px;
		width: 100vw;
		height: 30vh;
	}
	#output {
		width: 100%;
		margin-top: 0;
		margin-left: 30vw;
		overflow: scroll;
		clear: both;
	}
	.folder-list {
		border: 3px inset;
	}
	.email-list {
		border: 3px inset;
	}
	.mail-preview {
		border: 3px inset;
	}

	</style>

</head>

<body>
<textarea id="input"></textarea>
<div id="output"></div>
<script type="text/javascript">
var groupBy = function(xs, key) {
  return xs.reduce(function(rv, x) {
    (rv[x[key]] = rv[x[key]] || []).push(x);
    return rv;
  }, {});
};
function shuffle(a) {
    var j, x, i;
    for (i = a.length - 1; i > 0; i--) {
        j = Math.floor(Math.random() * (i + 1));
        x = a[i];
        a[i] = a[j];
        a[j] = x;
    }
    return a;
}
// Sam Squire
var template = {
	"data": [
	"div.blah div.blah div.blah 'hi'",
	"div.blah div.blah div.blah 'yellow'",
	"-ul li span p 'hi'",
	"ul li span p 'two'",
	"-ul li span p 'three'",
	]
}

function renderFlatHtml(template) {
	var data = template["data"];
	
	var children = [];
	var memo = {};
	var subChildren = [];
	var lastChildren = [];
	var childrenLookups = {};
	var created = {};
	var done = {};
	
	for (let i = 0 ; i < data.length ; i++) {
		var currentLine = data[i];
		var textNodes = currentLine.split("'");
		var processingNodes = textNodes[0].split(" ");
		for (let token of processingNodes) {
			created[token] = false;
			console.log("Marking", token, "as not created");
		}
	}

	for (let i = 0 ; i < data.length ; i++) {
		var pivot = false;
		var currentLine = data[i];
		var textNodes = currentLine.split("'");
		var pendingText = null;
		if (textNodes.length > 0) {
			pendingText = textNodes[1];
		}
		var processingNodes = textNodes[0].split(" ");
		processingNodes.pop();
		// console.log(processingNodes);
		
		if (memo.hasOwnProperty(textNodes[0])) {
			
		} else {
			memo[textNodes[0]] = [];
		}
		var freshNode = false;

		for (let j = 0; j < processingNodes.length ; j++) {
			var path = "";
			for (var m = 0 ; m <= j ; m++) {
				path += processingNodes[m].replace("-", "") + " ";
				
				if (!childrenLookups.hasOwnProperty(path)) {
					childrenLookups[path] = [];
					done[path] = false;
					// console.log("Creating", path);
				
				}
			}	
					
			// console.log(path);
			
		}
		
		if (processingNodes[0].charAt(0) == "-") {
			freshNode = true;
		}
		var line_indexes = [];
		
		for (let j = 0; j < processingNodes.length ; j++) {
			var path = "";
			for (var m = 0 ; m <= j ; m++) {
				path += processingNodes[m].replace("-", "") + " ";
			}

			var nextPath = "";
			for (var m = 0 ; m <= j + 1 && m < processingNodes.length ; m++) {
				nextPath += processingNodes[m].replace("-", "") + " ";
			}

			var end = false;
			if (nextPath == path) {
				end = true;
			}
			console.log("path", path, "nextpath", nextPath);
			
			
			var elements = processingNodes[j];
			console.log(elements);
			var siblingRoot = processingNodes[processingNodes.length - 2];
			
			
			if (memo.hasOwnProperty(siblingRoot)) {
		
			} else {
				memo[siblingRoot] = [];
			}
			
			if (elements.charAt(0) == "-") {
				elements = elements.substring(1);
				freshNode = true;
				var path = "";
				for (let j = 0; j < processingNodes.length ; j++) {
					path += processingNodes[j].replace("-", "") + " ";
					console.log("RESETTING", path);
					childrenLookups[path] = [];
					
					created[processingNodes[j]] = false;
					done[path] = false;
					
				}
			}
			var attributes = elements.split(".");
			var className = attributes[1];
			var element = attributes[0];

			if (element == siblingRoot) {
				pivotPoint = path;
				
			}
			
			if (end == true) {
				var textNode = React.createElement(element, {key: pendingText, "className": className}, pendingText);
				childrenLookups[path].push(textNode);
				console.log(childrenLookups[path]);
				created[element] = true;
				done[path] = true;
			} else if (j == 0 && done[path] == false) {
				console.log("Creating parent", path);
				childrenLookups[nextPath] = [];
				children.push(React.createElement(element, {className: className}, childrenLookups[nextPath]));
				created[element] = true;
				done[path] = true;
			} else if (done[path] === true) {
				console.log("Already created");
				console.log(element);
				
			} else if (done[path] == false) {
				childrenLookups[path].push(React.createElement(element, {className: className}, childrenLookups[nextPath]));
				done[path] = true;
				
				
			}
		}
		
	}
	
	return React.createElement("div", {}, children);
}

var output = document.getElementById("output");

document.getElementById("input").value = JSON.stringify(template, null, 4);
var inputField = document.getElementById("input");
inputField.addEventListener('change', function () {
	
	template = JSON.parse(inputField.value);
	rerender();
});
function rerender() {
	
	ReactDOM.render(renderFlatHtml(template), output);
}
rerender();
</script>




</body>
</html>

